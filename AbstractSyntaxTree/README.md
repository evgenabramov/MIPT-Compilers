# Абстрактное синтаксическое дерево + Visitor (2, 3 чекпоинты)

### Здесь я кратко опишу ход мысли и проделанную работу в рамках этого задания

2 и 3 чекпоинты я решил сделать вместе из-за того, что они тесно связаны (а 
именно `TreeNode` по своей семантике требует `Visitor` и наоборот)

Описанные предварительно правила грамматики в `parser.y` теперь нужно представить
в виде дерева, по которому можно перемещаться и собирать статистику кода. В частности,
как и в прошлом задании потребуются следующие сущности, теперь оформленные в виде классов:
- `Expression`
- `Statement`
- `Declaration`

По сути, старые правила теперь нужно записать в терминах ООП.
Структура наследования позаимствована из примера `03-parsers-with-ast`, 
класс `Assignment` был заменен на более общие понятия `Statement` и `Declaration`.
Чтобы разграничить код различных чекпоинтов, было введено пространство имен `ast::`

Идея наследования всех сущностей от класса `TreeNode` была заимствована из части 
репозитория курса про `Visitor` (`BaseElement` -> `TreeNode`)

Сами `Expression` не предполагают вычисления значения, это обеспечивается за счет
одного из `Visitor`'ов. (Однако до использования `Visitor` можно использовать [`eval`](https://github.com/akhtyamovpavel/CompilersCourse/blob/30c03655943e234f59b951429dc16bbc228a0041/04-visitors/expressions/Expression.h#L6))

Далее я доопределил правила грамматики, добавив к возможностям арифметического интерпретатора 
особенности языка MiniJava, причем теперь отдельным токенам соответствуют не просто числа и строки, 
а отдельные специализированные классы.

Поскольку `VariableDeclaration` - это и `Statement`, и `Declaration`, то чтобы не решать проблему ромбовидного наследования, заведены отдельно два класса `VariableDeclaration` и `VariableDeclarationStatement`.

Чтобы не решать проблемы со Scopes, пока `while` и `if` поддерживают только один `Statement`.

`Visitor` может посещать всех, даже базовые классы.

Примеров по 2 чекпоинту отдельно я не делал, так как что-то осознанное с AST можно сделать только с `Visitor`.

Пример кода программ, на которых работают `PrintVisitor` и `Interpreter`, можно посмотреть в директории `examples`.

## Описание запуска

```
mkdir build
cd build
cmake ..
make
./AbstractSyntaxTree --src ../examples/example[1-4].in
```

Посмотреть на выхлоп работы визиторов (2-3 чекпоинты):
```
cat PrintVisitor_output
cat Interpreter_output
```

4 чекпоинт:
```
cat PrintVisitor_output
cat SymbolTreeVisitor_output
```

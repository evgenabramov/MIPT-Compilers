# Компилятор языка MiniJava

Ветка `master` соответствует актуальной версии проекта 
и последнему чекпоинту. 

Код старых чекпоинтов в отрыве от остальных частей проекта 
можно посмотреть в соответствующих ветках.

---

## Установка пререквизитов

Вариант для пакетного менеджера **Ubuntu**:

```shell
sudo apt-get install arm-linux-gnueabihf qemu-user-static
```

--- 

## Пример работы

### **Сборка компилятора**

```shell
mkdir -p Compiler/build
cd Compiler/build
cmake ..
make
```

### **Запуск компилятора**

```shell
./Compiler --src ../examples/<example>
```

В результате в текущей директории *build* генерируются 
промежуточные файлы компиляции и ассемблерный код.

### **Запуск ассемблерного кода (с кросс-компилятором ARM)**

```shell
arm-linux-gnueabihf-gcc -static final_program.s -o final_program
./final_program
```

---

## Описание структуры и этапов работы компилятора

[main.cpp](Compiler/main.cpp) — обрабатывает переданные на вход компилятора параметры.

[driver.cpp](Compiler/driver.cpp) — связывает между собой отдельные компоненты компилятора.

### [Грамматика языка](Compiler/Grammar)

Правила грамматики описаны в файле `parser.y`.
Возможные токены - в файле `scanner.l`. См. [текстовое описание грамматики](Compiler/Grammar/README.md).

Во время компиляции для проверки корректности написанного кода 
и сбора статистики строится абстрактное синтаксическое дерево (`AST`), в 
котором каждая вершина соответствует терминальному или 
нетерминальному символу грамматики.

В частности, оформлены в виде классов и специализированы:
- `Declaration` (объявление)
- `Expression` (выражение)
- `Statement` (высказывание)
- `NamedEntity` (именованная сущность, она же lvalue)
- `Type` (тип)

`Service` - более абстрактные классы для связи текста программы 
воедино.

Лексический анализатор строится с помощью 
[Flex](https://linux.die.net/man/1/flex), синтаксический - с помощью 
[GNU Bison](https://www.gnu.org/software/bison/).

С полученным на первом этапе работы компилятора `AST` взаимодействуют несколько визиторов различного назначения: `PrintVisitor`, `SymbolTreeVisitor`, `MethodCallVisitor`, `TypeVisitor` и `IRTreeBuildVisitor`. Они используются для отладки, сбора статистики, проверки типов, моделирования стековых фреймов для функций и построения дерева промежуточного представления.

### [Таблица символов](Compiler/SymbolTable)

`ScopeLayer` - хранит информацию об именованных сущностях в текущей области видимости (классы, методы, примитивные типы). Использует абстрактный класс [`MemberType`](Compiler/MemberType).

`ScopeLayerTree` - дерево, образованное вложенными областями видимости, позволяющее реализовать shadowing переменных и определять такие ошибки компиляции, как объявление дважды в одной 
области видимости и использование без объявления.

Пример обхода этого дерева можно найти в `SymbolTreeVisitor.hpp`.

`ClassStorage` - хранилище полей и методов классов в программе. Используется вместе с порождающим паттерном **Singleton**.

### [Механизмы вызова функций](Compiler/MethodMechanisms)

Класс `Frame` предоставляет доступ к объектам в текущей области видимости, возвращаемому значению и родительскому фрейму.

`FunctionTable` - хранит индексы на стеке для переменных, доступных в текущей области видимости.

Класс `FrameTranslator` моделирует состояние Frame-а во время выполнения функции, а именно:

- Определяет место на стеке для:
    - Аргументов функции
    - Локальных переменных
- Хранит информацию о:
    - Числе аргументов функции
    - Размере стекового фрейма
- По названию переменной позволяет получать ее адрес в текущей области видимости. Адрес может быть в регистре или на стеке (см. [Address](Compiler/MethodMechanisms/Address))

### [Дерево промежуточного представления (IR Tree)](Compiler/IRTree)

Дерево промежуточного представления позволяет  перевести инструкции исходного языка на низкоуровневый (например, ассемблер) за счет использования ограниченного набора примитивных операций. Эти операции соответствуют вершинам построенного IR-дерева:

- Expression
    - `BINOP` (бинарная операция)
    - `CALL` (вызов функции)
    - `CONST` (константа)
    - `ESEQ` (последовательные *statement* и возврат значения)
    - `MEM` (обращение к памяти)
    - `NAME` (имя метки в другой операции)
    - `TEMP` (временная переменная)
- Statement
    - `EXP` (выражение, значение которого игнорируется)
    - `CJUMP` (условный переход к метке)
    - `LABEL` (создание метки)
    - `MOVE` (присваивание)
    - `SEQ` (последовательное выполнение *statements*)
- ExpressionList

**IR-дерево** строится из `AST` с помощью визитора [`IRTreeBuildVisitor`](Compiler/Visitors/IRTreeBuildVisitor.h). Для корректного преобразования типов вершин IR-дерева используется обертка `SubtreeWrapper`.

Для вывода и отладки построенного IR-дерева есть [`PrintVisitor`](Compiler/IRTree/Visitors/PrintVisitor.h).

Перед генерацией низкоуровневого кода построенное дерево приводится к каноническому виду за счет:

- Избавления от двойного `CALL`-а — когда среди переданных аргументов есть другой `CALL` ([`DoubleCallEliminateVisitor`](Compiler/IRTree/Visitors/DoubleCallEliminateVisitor.h))
- Поднятия вершин `ESEQ` на верхние уровни в дереве ([`ESEQEliminateVisitor`](Compiler/IRTree/Visitors/ESEQEliminateVisitor.h))
- Линеаризации — расположения `SEQ` в правостороннем порядке ([`LinearizationVisitor`](Compiler/IRTree/Visitors/LinearizationVisitor.h))

К построенному в результате дереву можно применить различные по уровню локальности оптимизации.

### [Блоки IR-дерева](Compiler/IRTree/Blocks) 

...

### [Генерация кода (перевод в ассемблер)](Compiler/IRTree/Visitors/CodeGenerationVisitor.h)

...

### [Аллокация регистров](Compiler/IRTree/Instructions)

...

---

## Использованные учебные материалы

- Лекции и семинары по курсу **"Языки программирования и теории компиляции"** в 4 семестре на Факультете Инноваций и Высоких Технологий МФТИ (в составе ФПМИ МФТИ)
    
    Лектор — [@akhtyamovpavel](https://github.com/akhtyamovpavel) 

- Andrew W. Appel, **Modern Compiler Implementation in Java**, Cambridge University Press

---

## Направления дальнейшего развития проекта

- [ ] Сделать поддержку процессоров с *CISC-архитектурой* (генерация кода **x86-64 Assembly**) 
- [ ] Проверить отсутствие утечек памяти
- [ ] Попробовать разрешить Shift/Reduce конфликты грамматики
- [ ] Доделать `TODO`-фичи в коде
- [ ] Добавить тесты
- [ ] Настроить CI с запуском тестов и примеров программ
- [ ] Сделать подсветку синтаксиса для популярного редактора кода
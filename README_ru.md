# Компилятор языка MiniJava

Ветка `master` соответствует актуальной версии проекта 
и последнему чекпоинту. 

Код старых чекпоинтов в отрыве от остальных частей проекта 
можно посмотреть в соответствующих ветках.

---

## Установка пререквизитов

Вариант для пакетного менеджера **Ubuntu**:

```shell
sudo apt-get install arm-linux-gnueabihf qemu-user-static
```

--- 

## Пример работы

### **Сборка компилятора**

```shell
mkdir -p Compiler/build
cd Compiler/build
cmake ..
make
```

### **Запуск компилятора**

```shell
./Compiler --src ../examples/<example>
```

В результате в текущей директории *build* генерируются 
промежуточные файлы компиляции и ассемблерный код.

### **Запуск ассемблерного кода (с кросс-компилятором ARM)**

```shell
arm-linux-gnueabihf-gcc -static final_program.s -o final_program
./final_program
```

---

## Описание структуры и этапов работы компилятора

[main.cpp](Compiler/main.cpp) — обрабатывает переданные на вход компилятора параметры.

[driver.cpp](Compiler/driver.cpp) — связывает между собой отдельные компоненты компилятора.

### [Грамматика языка](Compiler/Grammar)

Правила грамматики описаны в файле [`parser.y`](Compiler/Grammar/parser.y).
Возможные токены - в файле [`scanner.l`](Compiler/Grammar/scanner.l). См. [текстовое описание грамматики](Compiler/Grammar/README.md).

Во время компиляции для проверки корректности написанного кода 
и сбора статистики строится абстрактное синтаксическое дерево (`AST`), в 
котором каждая вершина соответствует терминальному или 
нетерминальному символу грамматики.

В частности, оформлены в виде классов и специализированы:
- [`Declaration`](Compiler/Grammar/Declaration) (объявление)
- [`Expression`](Compiler/Grammar/Expression) (выражение)
- [`Statement`](Compiler/Grammar/Statement) (высказывание)
- [`NamedEntity`](Compiler/Grammar/NamedEntity) (именованная сущность, она же lvalue)
- [`Type`](Compiler/Grammar/Type) (тип)

[Grammar/Service](Compiler/Grammar/Service) - более абстрактные классы для связи текста программы 
воедино.

Лексический анализатор строится с помощью 
[Flex](https://linux.die.net/man/1/flex), синтаксический - с помощью 
[GNU Bison](https://www.gnu.org/software/bison/).

С полученным на первом этапе работы компилятора `AST` взаимодействуют несколько визиторов различного назначения: [`PrintVisitor`](Compiler/Visitors/PrintVisitor.hpp), [`SymbolTreeVisitor`](Compiler/Visitors/SymbolTreeVisitor.hpp), [`MethodCallVisitor`](Compiler/Visitors/MethodCallVisitor.h), [`TypeVisitor`](Compiler/Visitors/TypeVisitor.hpp) и [`IRTreeBuildVisitor`](Compiler/Visitors/IRTreeBuildVisitor.h). Они используются для отладки, сбора статистики, проверки типов, моделирования стековых фреймов для функций и построения дерева промежуточного представления.

Посмотреть на результат работы `PrintVisitor` и `SymbolTreeVisitor`:

```shell
cat PrintVisitor_output
cat SymbolTreeVisitor_output
```

### [Таблица символов](Compiler/SymbolTable)

`ScopeLayer` - хранит информацию об именованных сущностях в текущей области видимости (классы, методы, примитивные типы). Использует абстрактный класс [`MemberType`](Compiler/MemberType).

`ScopeLayerTree` - дерево, образованное вложенными областями видимости, позволяющее реализовать shadowing переменных и определять такие ошибки компиляции, как объявление дважды в одной 
области видимости и использование без объявления.

Пример обхода этого дерева можно найти в `SymbolTreeVisitor.hpp`.

`ClassStorage` - хранилище полей и методов классов в программе. Используется вместе с порождающим паттерном **Singleton**.

### [Механизмы вызова функций](Compiler/MethodMechanisms)

Класс `Frame` предоставляет доступ к объектам в текущей области видимости, возвращаемому значению и родительскому фрейму.

`FunctionTable` - хранит индексы на стеке для переменных, доступных в текущей области видимости.

Класс `FrameTranslator` моделирует состояние Frame-а во время выполнения функции, а именно:

- Определяет место на стеке для:
    - Аргументов функции
    - Локальных переменных
- Хранит информацию о:
    - Числе аргументов функции
    - Размере стекового фрейма
- По названию переменной позволяет получать ее адрес в текущей области видимости. Адрес может быть в регистре или на стеке (см. [Address](Compiler/MethodMechanisms/Address))

### [Дерево промежуточного представления (IR Tree)](Compiler/IRTree)

Дерево промежуточного представления позволяет  перевести инструкции исходного языка на низкоуровневый (например, ассемблер) за счет использования ограниченного набора примитивных операций. Эти операции соответствуют вершинам построенного IR-дерева:

- Expression
    - `BINOP` (бинарная операция)
    - `CALL` (вызов функции)
    - `CONST` (константа)
    - `ESEQ` (последовательные *statement* и возврат значения)
    - `MEM` (обращение к памяти)
    - `NAME` (имя метки в другой операции)
    - `TEMP` (временная переменная)
- Statement
    - `EXP` (выражение, значение которого игнорируется)
    - `CJUMP` (условный переход к метке)
    - `LABEL` (создание метки)
    - `MOVE` (присваивание)
    - `SEQ` (последовательное выполнение *statements*)
- ExpressionList

**IR-дерево** строится из `AST` с помощью визитора [`IRTreeBuildVisitor`](Compiler/Visitors/IRTreeBuildVisitor.h). Для корректного преобразования типов вершин IR-дерева используется обертка `SubtreeWrapper`.

Для вывода и отладки построенного IR-дерева есть [`PrintVisitor`](Compiler/IRTree/Visitors/PrintVisitor.h).

Перед генерацией низкоуровневого кода построенное дерево приводится к каноническому виду за счет:

- Избавления от двойного `CALL`-а — когда среди переданных аргументов есть другой `CALL` ([`DoubleCallEliminateVisitor`](Compiler/IRTree/Visitors/DoubleCallEliminateVisitor.h))
- Поднятия вершин `ESEQ` на верхние уровни в дереве ([`ESEQEliminateVisitor`](Compiler/IRTree/Visitors/ESEQEliminateVisitor.h))
- Линеаризации — расположения `SEQ` в правостороннем порядке ([`LinearizationVisitor`](Compiler/IRTree/Visitors/LinearizationVisitor.h))

Посмотреть IR-дерево после работы визиторов:

```shell
cat <class name>_<function name>_IRTree_raw
cat <class name>_<function name>_IRTree_without_double_call
cat <class name>_<function name>_IRTree_without_ESEQ
cat <class name>_<function name>_IRTree_linearized
```

К построенному в результате дереву можно применить различные по уровню локальности оптимизации.

### [Блоки IR-дерева](Compiler/IRTree/Blocks) 

IR-блок — набор инструкций, которые обязаны выполниться последовательно, независимо от условий и переходов по меткам. Формально, каждый блок начинается с объявления метки и заканчивается `JUMP-` или `CJUMP-`инструкцией.

Такое упрощенное представление программы позволяет провести дополнительные оптимизации, в частности более эффективно назначать регистры временным переменным во время этапа генерации кода.

[`BlockBorderVisitor`](Compiler/IRTree/Visitors/BlockBorderVisitor.h) — отвечает за подготовку IR-дерева к построению IR-блоков, а именно:

- Закрывает неоконченный инструкцией `JUMP` блок перед объявлением метки
- Добавляет переход к эпилогу функции, в котором возвращается значение

Посмотреть IR-дерево после преобразования:

```shell
cat <class name>_<function_name>_IRTree_with_blocks
```

Построение блоков осуществляет [`BlockBuildVisitor`](Compiler/IRTree/Visitors/BlockBuildVisitor.h).

Посмотреть получившийся [граф](Compiler/IRTree/Blocks/BlockGraph.hpp) из IR-блоков:

```shell
cat <class name>_<function name>_IRTree_blocks
```

Для дополнительных оптимизаций несколько IR-блоков принято объединять в непересекающиеся следы ([Trace](Compiler/IRTree/Blocks/Trace.hpp)).

Посмотреть распределение блоков по следам:

```shell
cat <class name>_<function name>_IRTree_traces
```

### [Генерация кода (перевод в ассемблер)](Compiler/IRTree/Visitors/CodeGenerationVisitor.h)

За перевод в *ARM Assembly* отвечает визитор [`CodeGenerationVisitor`](Compiler/IRTree/Visitors/CodeGenerationVisitor.h).

Чтобы получить оптимальный по числу инструкций и промежуточных регистров код ассемблера, IR-дерево необходимо покрыть непересекающимися паттернами, состоящими из его вершин, образующих поддерево. Каждый паттерн необходимо рассматривать вручную, сопоставляя ему подходящий набор инструкций.

Существует два алгоритма покрытия IR-дерева паттернами: **Maximal munch** и **динамический**. В данном проекте реализован Maximal munch. Он предполагает рекурсивный обход дерева от корня к листьям, когда в текущей вершине последовательно проверяются паттерны от наибольшего по числу вершин к наименьшему. Если очередной паттерн подходит, соответствующая ему инструкция добавляется в общий список после рекурсивного обхода дочерних вершин.

Регистры на данном этапе заменены `Temporary`-переменными, т.е. считается, что в распоряжении есть бесконечное число виртуальных регистров.

Посмотреть результат работы `CodeGenerationVisitor`:

```shell
cat <class name>_<function name>.s
```

### [Аллокация регистров](Compiler/IRTree/Instructions)

В [инструкциях](Compiler/IRTree/Instructions/Instruction.hpp), полученных после генерации кода, учтены регистры, значения в которых влияют на результат и регистры, значения в которых изменяются.

Для перевода виртуальных регистров в физические необходимо выделить пары виртуальных регистров, которым не может быть назначен один и тот же физический регистр (построить граф конфликтов - [`InterferenceGraph`](Compiler/IRTree/Instructions/InterferenceGraph.hpp)). Предварительно строится [`ControlFlowGraph`](Compiler/IRTree/Instructions/ControlFlowGraph.hpp), в котором каждой инструкции соответствует отдельная вершина, а две инструкции соединены ребром, если после первой при некотором исполнении (в зависимости от условий) может следовать вторая. К нему применяется алгоритм поиска *актуальных* на ребрах переменных (**Liveness analysis**, переменная считается *актуальной* на ребрах между ее определением и использованием с этим значением), в ходе которого все вершины несколько раз перебираются в порядке, обратном порядку топологической сортировки. Во время этого перебора решаются уравнения потока (**Dataflow equations**).

Теперь исходная задача эквивалентна задаче раскраски графа конфликтов, когда связанные вершины не могут быть покрашены в один цвет. С учетом числа имеющихся в распоряжении регистров `InterferenceGraph` последовательно упрощается за счет исключения правильно подобранных вершин. Этим вершинам впоследствии можно назначить жадным образом цвета, отличные от цветов их соседей.

Посмотреть на ассемблерный код функций после назначения физических регистров (здесь `<iteration>` — номер итерации алгоритма покраски):

```shell
cat <class name>_<function name><iteration>.s
```

### [Полный код программы](Compiler/driver.cpp)

Для выполнения *calling conventions* к инструкциям каждой функции добавляются пролог и эпилог.

В начале функции:

- Сохраняется значение *Frame Pointer*
- *Stack Pointer* записывается во *Stack Pointer*
- Аллоцируется место на стеке для аргументов и локальных переменных
- Значения аргументов, переданных в регистрах, записываются на стек
- Сохраняются *callee-save* регистры

В конце функции:

- Возвращаемое значение записывается в регистр `r0` 
- Восстанавливаются значения *callee-save* регистров
- Восстанавливается значение *Stack Pointer*
- Восстанавливается значение *Frame pointer*
- Происходит переход по *Link register*

Для отладки и проверки корректности использовался [Compiler Explorer](https://godbolt.org).

Также добавляется `.data`-метка для корректной работы функции `printf` из библиотеки языка С.

После этого в [driver.cpp](Compiler/driver.cpp) код всех функций записывается в общий файл.

Посмотреть код программы, который можно запустить через **gcc**:

```shell
cat final_program.s
```

---

## Использованные учебные материалы

- Лекции и семинары по курсу **"Языки программирования и теории компиляции"** в 4 семестре на Факультете Инноваций и Высоких Технологий МФТИ (в составе ФПМИ МФТИ)
    
    Лектор — [@akhtyamovpavel](https://github.com/akhtyamovpavel) 

- Andrew W. Appel, **Modern Compiler Implementation in Java**, Cambridge University Press

---

## Направления дальнейшего развития проекта

- [ ] Сделать поддержку процессоров с *CISC-архитектурой* (генерация кода **x86-64 Assembly**) 
- [ ] Проверить отсутствие утечек памяти
- [ ] Попробовать разрешить Shift/Reduce конфликты грамматики
- [ ] Доделать `TODO`-фичи в коде
- [ ] Добавить тесты
- [ ] Настроить CI с запуском тестов и примеров программ
- [ ] Сделать подсветку синтаксиса для популярного редактора кода